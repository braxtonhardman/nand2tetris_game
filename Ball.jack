//This is the ball class for drawing the balls to hit the person
//05/04/2025

class Ball
{
    field int x, y, vx, vy, ballR; //basics for the ball height and speed and what not
    field int gravity; //gravity constants to work with our parabolic eqautions
    field boolean right, ballStop; //used to see what direction we need to go for x and when to stop the ball
    field int prevX, prevY; //used to keep track of the previous ball
    
    //Make the constructor for the ball
    constructor Ball new(int startX, int startY, int xPow, int yPow, boolean rightIn)
    {
        // initialize all the fields correctly
        let x = startX;
        let y = startY;
        let gravity = 2;
        let ballR = 5;
        let right = rightIn;
        let ballStop = false;

        //initalize the prevX and Y for later calculations
        let prevX = 0;
        let prevY = 0;

        //Now set the values for how we are gonna calculate the ball movement
       if(right) //player is shooting right (adjust x velocity)
       {
            let vx = xPow;
       }
       else //player is shooting left so move x-pow to negative
       {
            let vx = -xPow;
       }

       //Now since we're dealing with pixel space closer to the ground means a positive y so we're gonan invert the y-value so the ball can go "up" in the user perspective
       let vy = -yPow;

        return this;
    }   


    //Now create the move function to calculate the ball's next x and y address
    method void move()
    {
        //variable declarations
        var int diameter; //diameter for the ball based on radius to use for boundry calculations

        if(~ballStop)
        {
            let diameter = Math.multiply(ballR,2);
            let prevX = x;
            let prevY = y;

            //Update the position and then apply the gravity to vertical velocity (over time)
            let x = x + vx;
            let y = y + vy;
            let vy = vy + gravity;

            //check and make sure that X can't go above or below the memory mapp; Since diameter
            if(x < (0 + diameter))
            {
                let x = (0 + diameter);
            }
            if(x > (511 - diameter))
            {
                let x = (511 - diameter);
            }

            //Now do the same thing for Y
            if(y < (0 + diameter))
            {
                let y = (0 + diameter);
                let vy = 0; //hit the ceeling stop the ball
            }
            if (y > (255 - diameter))
            {
                let y = (255 - diameter);
                let vy = 0; //ball is on the ground
                let vx = 0;
                let ballStop = true; //make sure the ball doesn't move any more
            }
        }
        do animateToNewBall();

        return;
    }

    method void animateToNewBall() //this method animates the ball to the X value
    {
        //variables used to do the calculation
        var int dx, dy, drawX, drawY, steps, i, work;

        //Now update ball animation and moveemnt for smoother motion
        let dx = x - prevX; //deltaX
        let dy = y - prevY; //deltaY

        if(Math.abs(dx) > Math.abs(dy)) //determine if there is more change in the x or y for our animation
        {
            let steps = Math.abs(dx);
        }
        else
        {
            let steps = Math.abs(dy);
        }

        let i = 0;
        while(i < steps) //loop over the number of steps to reanimate the change in that we covered
        {
            //guys this equation I found is called linear interploation to calculate the change. prevX = prevX + (dx * i) /steps
            //drawX and drawY are abirtray values to track each time we draw and animate and also so that we don't override prevX and X
            let drawX = prevX + Math.divide(Math.multiply(dx, i), steps);
            let drawY = prevY + Math.divide(Math.multiply(dy, i), steps);

            //now draw the balls
            do Screen.setColor(true);
            do Screen.drawCircle(drawX,drawY,ballR);

            //Make the computer do work so the balls can show up on screen
            let work = 0;
            while(work < 1000) 
            { 
                let work = work + 1; 
            }

            do Screen.setColor(false);
            do Screen.drawCircle(drawX,drawY,ballR);
            let i = i + 1;
        }

        return;
    }

    //now do the draw method for our ball
    method void draw()
    {
        do Screen.setColor(true);
        do Screen.drawCircle(x,y,ballR);
        return;
    }

    method void clearBall() //erase the ball
    {
        do Screen.setColor(false); //basically setting the color to white
        do Screen.drawCircle(x,y,ballR);
        return;
    }

    //couple accessors and mutators for the current x & y of the ball
    method void setX(int xIn)
    {
        let x = xIn;
        return;
    }
    method void setY(int yIn)
    {
        let y = yIn;
        return;
    }
    method void setVX(int vxIn)
    {
        let vx = vxIn;
        return;
    }
    method void setVY(int vyIn)
    {
        let vy = vyIn;
        return;
    }
    method int getX()
    {
        return x;
    }
    method int getY()
    {
        return y;
    }
    method int getVX()
    {
        return vx;
    }
    method int getVY()
    {
        return vy;
    }
    method boolean getBallStop() //get whether or not the ball is stopped
    {
        return ballStop;
    }
    method int getBallR() //grab the radius of the ball
    {
        return ballR;
    }
}